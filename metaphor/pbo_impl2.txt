void Texture::createPBO()
    {
        spCheck(glGenBuffersARB(1, &m_pack_pbo))
        spCheck(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, m_pack_pbo))
        spCheck(glBufferDataARB(GL_PIXEL_PACK_BUFFER_ARB, m_size.x * m_size.y * 4, NULL, GL_STREAM_DRAW_ARB))

        spCheck(glGenBuffersARB(1, &m_unpack_pbo))
        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_unpack_pbo))
        spCheck(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_size.x * m_size.y * 4, NULL, GL_STREAM_DRAW_ARB))
        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0))
    }

    //a pbo is a way to transfer data between buffer and textures..
         void Texture::clearArea(int x, int y, int width, int height)
    {
        GLubyte* data_write = NULL;
        GLubyte* data_read = NULL;

        if(!m_pbo_created)
        {
            createPBO();
            m_pbo_created = true;
        }
        spCheck(glPixelStorei(GL_UNPACK_ALIGNMENT,  4))
        spCheck(glPixelStorei(GL_PACK_ALIGNMENT,  4))

//===================================================================
        spCheck(glBindTexture(GL_TEXTURE_2D, m_tex_obj))
        spCheck(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, m_pack_pbo))
        spCheck(glGetTexImage(GL_TEXTURE_2D, 0, m_format, GL_UNSIGNED_BYTE, NULL))
        spCheck( data_read = (GLubyte*)glMapBufferARB(GL_PIXEL_PACK_BUFFER_ARB, GL_READ_ONLY_ARB))


		/*
         *  if a buffer is bound, the last parameter is treated as an offset to that buffer's data store,
         *  otherwise is a pointer to client's data store (unpacking treated relative to client's pointer)..
         */
        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_unpack_pbo))
        spCheck(glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_size.x, m_size.y, m_format, GL_UNSIGNED_BYTE, NULL))


        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_unpack_pbo))
        spCheck(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_size.x * m_size.y * 4, NULL, GL_STREAM_DRAW_ARB))
        spCheck( data_write = (GLubyte*)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY_ARB))
        if(data_write && data_read)
        {
            int dataPitch = m_size.x * 4;


            size_t counter  = 0;
            size_t offset   = 0; //(y * width + x);
            GLubyte* start  = data_write;
            GLubyte* read   = data_read;
            GLubyte* end    = start + m_size.x * m_size.y * 4;

            /**
             *  p   ... read_data
             *  N   ... row number
             *
             *  k   defined as:
             *
             *  if(s >= a)
             *      k = n * l
             *  else
             *      k = a / s * ceil(s * n * l / a)
             *
             *  n   ... number of elements in a group
             *  l   ... number of elements in a row
             *  s   ... size of an element in basic machine units (GLubyte)
             *  a   ... GL_UNPACK_ALIGNMENT
             *
             *  advancement:
             *  p = GL_UNPACK_SKIP_PIXELS * n + GL_UNPACK_SKIP_ROWS * k
             *
             */
            for(size_t _y = 0; _y < m_size.y; _y++)
            {
                for(size_t _x = 0; _x < m_size.x; _x++)
                {
                    if(
                        (_x > x && _x <= x + width)
                    &&  (_y > x && _y <= y + height)
                       )
                    {
                        memset(data_write, 0, sizeof(char) * 4);
                    }
                    else
                    {
                        memcpy(data_write, data_read, sizeof(char) * 4);
                    }
                    data_read  += 4;
                    data_write += 4;
                }
            }

            bool unmap = false;
            spCheck(unmap = glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB))
            if(!unmap)
            {
                SP_PRINT_WARNING("failed to unmap buffer");
            }


            spCheck(unmap = glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB))
            if(!unmap)
            {
                SP_PRINT_WARNING("failed to unmap buffer");
            }



            spCheck(glActiveTextureARB(GL_TEXTURE0_ARB))
            spCheck(glBindTexture(GL_TEXTURE_2D, m_tex_obj))
            spCheck(glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_size.x, m_size.y, m_format, GL_UNSIGNED_BYTE, NULL))
        }
        else
        {
            //printf("no mapping..\n");
            bool unmap = false;
            spCheck(unmap = glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB))
            if(!unmap)
            {
                SP_PRINT_WARNING("failed to unmap buffer");
            }

            spCheck(unmap = glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB))
            if(!unmap)
            {
                SP_PRINT_WARNING("failed to unmap buffer");
            }
        }
        spCheck(glBindTexture(GL_TEXTURE_2D, 0))
        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0))
        spCheck(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0))
        spCheck(glFlush())
    }