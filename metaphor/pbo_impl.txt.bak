    void Texture::clearArea(int x, int y, int width, int height)
    {
        GLubyte* data_write = NULL;
        GLubyte* data_read = NULL;


        spCheck(glPixelStorei(GL_UNPACK_ALIGNMENT,  4))
        spCheck(glPixelStorei(GL_PACK_ALIGNMENT,  4))

        spCheck(glGenBuffersARB(1, &m_pack_pbo))
        spCheck(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, m_pack_pbo))
        spCheck(glBufferDataARB(GL_PIXEL_PACK_BUFFER_ARB, m_size.x * m_size.y * 4, NULL, GL_STREAM_DRAW_ARB))

        spCheck(glGenBuffersARB(1, &m_unpack_pbo_0))
        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_unpack_pbo_0))
        spCheck(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_size.x * m_size.y * 4, NULL, GL_STREAM_DRAW_ARB))

        spCheck(glGenBuffersARB(1, &m_unpack_pbo_1))
        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_unpack_pbo_1))
        spCheck(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_size.x * m_size.y * 4, NULL, GL_STREAM_DRAW_ARB))

        //spCheck(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, width * height * 4, NULL, GL_STREAM_DRAW_ARB))

        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0))

//===================================================================
        spCheck(glBindTexture(GL_TEXTURE_2D, m_tex_obj))
        spCheck(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, m_pack_pbo))
        spCheck(glGetTexImage(GL_TEXTURE_2D, 0, m_format, GL_UNSIGNED_BYTE, NULL))
        spCheck( data_read = (GLubyte*)glMapBufferARB(GL_PIXEL_PACK_BUFFER_ARB, GL_READ_ONLY_ARB))


        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_unpack_pbo_0))
        spCheck(glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_size.x, m_size.y, m_format, GL_UNSIGNED_BYTE, NULL))

        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_unpack_pbo_1))
        spCheck(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, m_size.x * m_size.y * 4, NULL, GL_STREAM_DRAW_ARB))
        spCheck( data_write = (GLubyte*)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY_ARB))
        if(data_write && data_read)
        {
            int dataPitch = m_size.x * 4;


            size_t counter  = 0;
            size_t offset   = 0; //(y * width + x);
            GLubyte* start  = data_write + offset;
            GLubyte* read   = data_read;
            GLubyte* end    = start + m_size.x * m_size.y * 4;

            /*
            while(start != end)
            {
                if(counter > width)
                {
                    start       += sizeof(char) * m_size.x * 4;
                    data_read   += sizeof(char) * m_size.x * 4;
                    counter = 0;
                }

                *start++ = *read++;
                *start++ = *read++;
                *start++ = *read++;
                *start++ = *read++;

                counter++;
            }
            */
            bool toggle = true;
            int* ptr = reinterpret_cast<int*>(data_write);
            int color = 0;


            for(size_t _y = 0; _y < m_size.y; _y++)
            {
                for(size_t _x = 0; _x < m_size.x; _x++)
                {


                    *data_write++ = *data_read++;
                    *data_write++ = *data_read++;
                    *data_write++ = *data_read++;
                    *data_write++ = *data_read++;
                }
                //read += (_y * width + x) * 4;
            }


            /*
            memcpy(data_write, data_read, m_size.x * m_size.y * 4);
            size_t total_length = m_size.x * m_size.y;

            for(size_t i = 0; i < total_length - total_length / 32; i++)
            {
                *data_write++ = 0;
                *data_write++ = 0;
                *data_write++ = 0;
                *data_write++ = 255;
            }
            */
            /*
            for(size_t _y = y; _y < height; _y++)
            {
                for(size_t _x = x; _x < width; _x++)
                {
                    //start = data_write + (x + y * m_size.x) * 4;
                    *data_write++ = 255;
                    *data_write++ = 255;
                    *data_write++ = 255;
                    *data_write++ = 255;
                }
            }*/


            //memcpy(data_write, data_read, m_size.x * m_size.y * 4);


            bool unmap = false;
            spCheck(unmap = glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB))
            if(!unmap)
            {
                SP_PRINT_WARNING("failed to unmap buffer");
            }


            spCheck(unmap = glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB))
            if(!unmap)
            {
                SP_PRINT_WARNING("failed to unmap buffer");
            }



            spCheck(glActiveTextureARB(GL_TEXTURE0_ARB))
            spCheck(glBindTexture(GL_TEXTURE_2D, m_tex_obj))
            spCheck(glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_size.x, m_size.y, m_format, GL_UNSIGNED_BYTE, NULL))
        }
        else
        {
            bool unmap = false;
            spCheck(unmap = glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB))
            if(!unmap)
            {
                SP_PRINT_WARNING("failed to unmap buffer");
            }

            spCheck(unmap = glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB))
            if(!unmap)
            {
                SP_PRINT_WARNING("failed to unmap buffer");
            }
        }

//===================================================================

        spCheck(glBindTexture(GL_TEXTURE_2D, 0))
        spCheck(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0))
        /*
        spCheck(glDeleteBuffersARB(GL_PIXEL_UNPACK_BUFFER_ARB, &m_unpack_pbo_0))
        spCheck(glDeleteBuffersARB(GL_PIXEL_UNPACK_BUFFER_ARB, &m_unpack_pbo_1))
        */
    }